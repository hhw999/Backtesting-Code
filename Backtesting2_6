import pandas as pd
import yfinance as yf
import mplfinance as mpf
from backtesting import Backtest, Strategy
from backtesting.lib import crossover, plot_heatmaps, resample_apply, barssince
from datetime import datetime, time
from pytz import UTC  # Import the UTC timezone from pytz library

# Download the data 
# (return = +2% in 6 total placed trades accross the 2x weeks between 8/8/23 to 19/8/23 when traded manually)
min15_data = yf.download(tickers = 'GBPUSD=X' ,start="2023-8-6", end="2023-8-19", interval = '15m')

def identify_fractals(data):
    """Identify fractals based off of code from Trading view"""
    
    # Fractal period
    fractal_period = 5
    fractal_dates = []

    def is_bill_williams_fractal(high, low, index):
        if index < 4 or index >= len(high) - 4:
            return False
        fractal_high = high[index]
        fractal_low = low[index]
        is_high = fractal_high >= max(high[index - 2:index + 3]) and fractal_high >= max(high[index - 1:index + 4])
        is_low = fractal_low <= min(low[index - 2:index + 3]) and fractal_low <= min(low[index - 1:index + 4])
        return is_high or is_low

    def is_regular_fractal(high, low, index):
        if index < fractal_period or index >= len(high):
            return False
        fractal_high = high[index]
        fractal_low = low[index]
        is_high = fractal_high >= max(high[index - fractal_period:index + 1])
        is_low = fractal_low <= min(low[index - fractal_period:index + 1])
        return is_high or is_low

    for i in range(len(data)):
        if is_bill_williams_fractal(data['High'], data['Low'], i):
            fractal_dates.append((data.index[i], 'fractal_high'))
        elif is_regular_fractal(data['High'], data['Low'], i):
            fractal_dates.append((data.index[i], 'fractal_low'))

    data['Fractal'] = ''
    for date, fractal_type in fractal_dates:
        data.loc[date, 'Fractal'] = fractal_type

    # Filter consecutive "fractal_low" and keep only the lowest low
    mask = data['Fractal'] == 'fractal_low'
    consecutive_groups = (mask != mask.shift()).cumsum()
    for group_id, group_data in data[mask].groupby(consecutive_groups):
        lowest_low_index = group_data['Low'].idxmin()
        data.loc[group_data.index, 'Fractal'] = ''
        data.loc[lowest_low_index, 'Fractal'] = 'fractal_low'

    # Filter consecutive "fractal_high" and keep only the highest high
    mask = data['Fractal'] == 'fractal_high'
    consecutive_groups = (mask != mask.shift()).cumsum()
    for group_id, group_data in data[mask].groupby(consecutive_groups):
        highest_high_index = group_data['High'].idxmax()
        data.loc[group_data.index, 'Fractal'] = ''
        data.loc[highest_high_index, 'Fractal'] = 'fractal_high'

    data = data.dropna(subset=['Open'])
    data.index = data.index.tz_localize(None)

    return data

def check_time_range(current_time):
    """Function to check if the current_time is out of kill zone. Return True if out of KZ."""
    # Convert the timestamp to UTC timezone
    # timestamp_utc = timestamp.tz_localize(UTC)

    # # Extract the time from the timestamp
    # current_time = timestamp_utc.time()

    # Define time ranges in UTC
    time_range_1_start = time(8, 0)
    time_range_1_end = time(10, 30)
    time_range_2_start = time(12, 30)
    time_range_2_end = time(15, 0)
    # Check if the time is within either of the defined ranges
    if (time_range_1_start < current_time <= time_range_1_end) or \
        (time_range_2_start < current_time <= time_range_2_end):
        return False
    else:
        return True

def identify_bar(data):
    """Add a 'bar' column with 'Red' or 'Green' based on Close and Open prices."""
    data = data.copy()
    data['Bar'] = 'Green'  # Initialize 'bar' column with 'Green'
    red_mask = data['Close'] < data['Open']  # Create a mask for 'Red' bars
    data.loc[red_mask, 'Bar'] = 'Red'  # Set 'bar' to 'Red' for rows where Close < Open
    return data

class HTF(Strategy): 
    position_exposure = 0.01                            #1% of available cash position
    Stop_Pips = 0.0002                                  #2 pip extra on SL
    
    #key levels
    H4_high = 0                                             
    H4_low = 0
    H4_last_fractal_high = 0
    H4_last_fractal_low = 0

    fractal_high = 0
    fractal_low = 0
    fractal_high_validity = 0
    fractal_low_validity = 0

    Min15_high = 0
    Min15_low = 0
    Min15_high_validity = 0
    Min15_low_validity = 0 

    directional_bias = 0
    open_orders = []


    def init(self):
        # Resample to 4-hour data with custom time offset
        h4_data = min15_data.resample('4H', offset='2H').agg({
            'Open': 'first',
            'High': 'max',
            'Low': 'min',
            'Close': 'last',
            'Volume': 'sum'
        })
        
        # Identify fractal H/L for all data (A bit of look ahead bias here?)
        self.h4_data_fractal_1 = identify_fractals(h4_data)
        self.min15_data_fractal_1 = identify_fractals(min15_data)

        # Identify candles as Bullish or Bearish
        self.h4_data_fractal = identify_bar(self.h4_data_fractal_1)
        self.min15_data_fractal = identify_bar(self.min15_data_fractal_1)

        self.open_orders = pd.DataFrame(columns=['Datetime', 'Type', 'Limit', 'SL', 'TP', 'Size', 'IsOpen'])
        self.Limit_orders_not_met = pd.DataFrame(columns=['Datetime', 'Type', 'Limit', 'SL', 'TP', 'Size', 'IsOpen'])
        self.pending_orders = []  # Track pending orders
        self.potential_orders = pd.DataFrame(columns=['Datetime', 'Type', 'Limit', 'SL', 'TP', 'Size', 'IsOpen'])

        print(self.h4_data_fractal)
        #  plot of price and fractals line chart
        self.fractal_values = []
        # append fractals to data to fractal values for plot
        for index in self.h4_data_fractal.index:
            if self.h4_data_fractal.loc[index, 'Fractal'] == 'fractal_high':
                self.fractal_values.append(1)
            elif self.h4_data_fractal.loc[index, 'Fractal'] == 'fractal_low':
                self.fractal_values.append(-1)
            else:
                self.fractal_values.append(0)
        for index in self.min15_data_fractal.index:
            if self.h4_data_fractal.loc[index, 'Fractal'] == 'fractal_high':
                self.fractal_values.append(1)
            elif self.h4_data_fractal.loc[index, 'Fractal'] == 'fractal_low':
                self.fractal_values.append(-1)
            else:
                self.fractal_values.append(0)

        # Plot the candlestick chart with the bar chart as an addplot
        addplot_bar = mpf.make_addplot(
            self.fractal_values,
            panel=1,
            secondary_y=False,
            color='b',
            alpha=0.5,
            width=0.5
        )
        fig, axlist = mpf.plot(self.h4_data_fractal, type='candle', addplot=addplot_bar, ylabel='Price', tight_layout=True, returnfig=True)
        mpf.show()
        
    def update_H4_range(self, current_bar):
        """Updates H4 range to define trading range"""
        if current_bar['High'] > self.H4_high:
            self.H4_high = current_bar['High']
            
            if self.H4_last_fractal_low < current_bar['Low']:
                self.H4_low = self.H4_last_fractal_low
            else:
                self.H4_low = current_bar['Low']
            
            self.H4_equ = ((self.H4_high - self.H4_low) / 2) + self.H4_low
            self.upper_dead = 6 * ((self.H4_high - self.H4_low) / 10) + self.H4_low
            self.lower_dead = 4 * ((self.H4_high - self.H4_low) / 10) + self.H4_low

        if current_bar['Low'] < self.H4_low:
            self.H4_low = current_bar['Low']
            
            if self.H4_last_fractal_high > current_bar['High']:
                self.H4_high = self.H4_last_fractal_high
            else:
                self.H4_high = current_bar['High']
            
            self.H4_equ = ((self.H4_high - self.H4_low) / 2) + self.H4_low
            self.upper_dead = 6 * ((self.H4_high - self.H4_low) / 10) + self.H4_low
            self.lower_dead = 4 * ((self.H4_high - self.H4_low) / 10) + self.H4_low

    def determine_directional_bias(self):
        if self.H4_high > 0 and self.H4_low > 0:
            h4_bars = self.h4_data_fractal.resample('4H').last()

            previous_h4_high = self.H4_high
            previous_h4_low = self.H4_low

            current_h4_bar = h4_bars.iloc[-1]

            if current_h4_bar['High'] > previous_h4_high:
                self.directional_bias = 0  # Unconfirmed NFT
                next_h4_bar = h4_bars.iloc[-2]  # Get the next H4 bar
                if next_h4_bar['Low'] > previous_h4_high:
                    self.directional_bias = 2  # Confirm the bias as 2 (SFT to the up side)
                else: self.directional_bias = 0 # Set as FT/NFT
            elif current_h4_bar['Low'] < previous_h4_low:
                self.directional_bias = 0  # Unconfirmed NFT
                next_h4_bar = h4_bars.iloc[-2]  # Get the next H4 bar
                if next_h4_bar['High'] < previous_h4_low:
                    self.directional_bias = -2  # Confirm the bias as -2, (SFT to the down side)
                else: self.directional_bias = 0 # Set as FT/NFT

            else:
                self.directional_bias = 1  # Setting the bias to 0

    def BUY(self, current_bar, timestamp_utc):
        '''Buy function. Will place a long limit order'''

        Long_StopLoss = round(current_bar['Low'], 4) - self.Stop_Pips
        Long_Size = round((self.equity * self.position_exposure) / (current_bar['High'] - Long_StopLoss))
        Long_TakeProfit = round((current_bar['High'] + (3*(current_bar['High']-Long_StopLoss))),4)
               
        # print('buy - current bar', current_bar)
        # print('sl', Long_StopLoss)
        # print('tp',Long_TakeProfit)
        # print('position size', Long_Size)
        
        if Long_TakeProfit >= self.H4_high:
            print('TP out of range')
            return

        order = self.buy(limit = current_bar['High'], sl= Long_StopLoss, tp = Long_TakeProfit, size = Long_Size)
        self.pending_orders.append(order)

        # Add Limit Order to open_orders to track pending orders
        new_order = pd.DataFrame({
            'Datetime': [timestamp_utc],
            'Type': ['BUY'], 
            'Limit': [current_bar['High']], 
            'SL': [Long_StopLoss],
            'TP': [Long_TakeProfit], 
            'Size': [self.position_exposure], 
            'IsOpen': [True]})

        
        # print("new order", new_order)
        self.open_orders = pd.concat([self.open_orders, new_order], ignore_index=True)

    def SELL(self, current_bar, timestamp_utc):
        '''Sell function. Will place a short limit order'''
        # print('sell - current bar', current_bar)
        # print('equity',self.equity)
        # print('pos exposure', self.position_exposure)

        Short_StopLoss = round(current_bar['High'], 4) + self.Stop_Pips
        Short_Size = round((self.equity * self.position_exposure) / ((Short_StopLoss - current_bar['Low'])))
        Short_TakeProfit = round((current_bar['Low'] - (3*(Short_StopLoss-current_bar['Low']))),4)
       
        # print('sl', Short_StopLoss)
        # print('position size', Short_Size)
        # print('tp', Short_TakeProfit)
        # print('4h low', self.H4_low)
       
        if Short_TakeProfit <= self.H4_low:
            print('TP out of range')
            return  
        
        order = self.sell(limit = current_bar['Low'], sl= Short_StopLoss, tp = Short_TakeProfit, size = Short_Size)
        self.pending_orders.append(order)

        # Add limit order to open_orders to track pending orders
        new_order = pd.DataFrame({
            'Datetime': [timestamp_utc],
            'Type': ['SELL'], 
            'Limit': [current_bar['Low']], 
            'SL': [Short_StopLoss],
            'TP': [Short_TakeProfit], 
            'Size': [self.position_exposure], 
            'IsOpen': [True]})
        # print("new order", new_order)
        self.open_orders = pd.concat([self.open_orders, new_order], ignore_index=True)

    def notify_order(self, order):
        if order.status == order.Completed:
            # Find the order in the open_orders DataFrame
            order_index = self.open_orders[(self.open_orders['Type'] == order.type) &
                                           (self.open_orders['Limit'] == order.price) &
                                           (self.open_orders['Size'] == order.size)].index

            if not order_index.empty:
                self.open_orders.at[order_index[0], 'IsOpen'] = False

    def close_pending_orders_after_fill(self):
        """Close a limit order after it has been filled. Close all instances where IsOpen = False."""
        for index, order in self.open_orders.iterrows():
            if not order['IsOpen']:
                self.Limit_orders_not_met = pd.concat([self.Limit_orders_not_met, order], ignore_index=True)
                self.open_orders.drop(index, inplace=True)            

    def close_pending_orders(self):
        for order in self.pending_orders:
            # Iterate through pending orders and find the corresponding order to cancel
            order_to_cancel = None
            for pending_order in self.orders:
                if order.limit == pending_order.limit and order.size == pending_order.size:
                    order_to_cancel = pending_order
                    break
            
            if order_to_cancel:
                order_to_cancel.cancel()
        
        self.pending_orders.clear()

    def check_dead_zone(self, Entry_Price):
        """Check if current entry price is within Kill zone. Return True if entry price is not in Dead Zone (+-10% around EQU.)"""
        if self.upper_dead > Entry_Price > self.lower_dead:
            return False

        else: return True

    def check_sweep_origin(self, min15_data_fractal, current_index):
        """Checks where the liquidity sweep originates.
        Return True when the sweep origin is within the KZ."""
        last_color_change_index = None
        current_index_int = min15_data_fractal.index.get_loc(current_index)

        for index, row in min15_data_fractal.iloc[current_index_int::-1].iterrows():
            if row['Bar'] != min15_data_fractal.at[current_index, 'Bar']:
                last_color_change_index = min15_data_fractal.index[min15_data_fractal.index.get_loc(index) + 1]
                break  # Exit the loop as soon as a color change is found

        # Convert the last color change timestamp to UTC and extract its time
        last_color_change_time = last_color_change_index.tz_localize(UTC).time()
        if check_time_range(last_color_change_time):    # Returns true when out of KZ which returns check_sweep_origin = False
            return False  
        else: return True                                      # The origin of the sweep is within the kill zone

    def next(self):        
        current_index = self.data.index[-1]  
        current_bar = self.min15_data_fractal.loc[current_index]
        timestamp_utc = current_index.tz_localize(UTC)              # Convert the timestamp to UTC timezone
        current_time = timestamp_utc.time()                         # Extract the time from the timestamp

        # Fill open limit orders or extend entry 
        for index, order in self.open_orders.iterrows():
            if order['IsOpen']:
                if order['Type'] == 'BUY' and current_bar['High'] >= order['Limit']:
                    # if a Buy order is filled in the current bar
                    self.open_orders.at[index, 'IsOpen'] = False
                
                elif order['Type'] == 'SELL' and current_bar['Low'] <= order['Limit']:
                    # if a sell order is filled in the current bar
                    self.open_orders.at[index, 'IsOpen'] = False
                
                elif order['Type'] == 'BUY' and current_bar['High'] < order['Limit'] and current_bar['Low'] < self.data.Low[-2] and current_index == (order['Datetime'] + pd.Timedelta(minutes=15)):
                    # continued long entry, cancel order and place new buy limit order
                    order_to_cancel = order.loc[index]
                    print('orders before:', self.open_orders)
                    order_to_cancel.cancel() #I DONT THINK THIS CANCEL IS WORKING 
                    print('orders before:', self.open_orders)

                    self.BUY(current_bar, timestamp_utc)
               
                elif order['Type'] == 'SELL' and current_bar['Low'] > order['Limit'] and current_bar['High'] > self.data.High[-2] and current_index == (order['Datetime'] + pd.Timedelta(minutes=15)):
                    # continued short entry, cancel order and place new sell limit order
                    order_to_cancel = order.loc[index]
                    print('orders before:', self.open_orders)

                    order_to_cancel.cancel() #I DONT THINK THIS CANCEL IS WORKING
                    print('orders before:', self.open_orders)

                    self.SELL(current_bar, timestamp_utc)
                    
        self.close_pending_orders_after_fill()
    
        if current_time == time(10, 30) or current_time == time(15, 0):     # Close pending orders at end of kill zone
            self.close_pending_orders()

        # Check Killzone
        if  check_time_range(current_time) == False: 
            # Sweep Sell side fractal liquidity or Sweep Sell side 15Min range liquidity
            if   (  current_bar['High'] > self.fractal_high and self.fractal_high_validity == 1        and  \
                    current_bar['High'] < self.H4_high and current_bar['Low'] > self.H4_low            )or  \
                (  current_bar['High'] > self.Min15_high                                               and  \
                    current_bar['High'] < self.H4_high and current_bar['Low'] > self.H4_low        ):
                
                if self.check_sweep_origin(self.min15_data_fractal, current_index):                 #Check if liquidity sweep began within KZ
                    if current_bar['Low'] > self.H4_equ and self.directional_bias != 0 and self.check_dead_zone(current_bar['Low']):       # FT/NFT
                        self.SELL(current_bar, timestamp_utc)
                    elif self.directional_bias == -2 and self.check_dead_zone(current_bar['Low']):       # IF SFT to the down side
                        self.SELL(current_bar, timestamp_utc)
                    else: 
                        # add to potential order list. If continued entry point drops below equ then enter 
                        new_order = pd.DataFrame({
                            'Datetime': [timestamp_utc],
                            'Type': ['SELL'], 
                            'Limit': [current_bar['Low']], 
                            'SL': [0],
                            'TP': [0], 
                            'Size': [self.position_exposure], 
                            'IsOpen': [True],
                            'Bar': [current_bar['Bar']] })
                        self.potential_orders = pd.concat([self.potential_orders, new_order], ignore_index=True)

            # Sweep Buy side liquidity or Sweep Buy side 15Min range liquidity
            elif (  current_bar['Low'] < self.fractal_low and self.fractal_low_validity == 1             and  \
                    current_bar['High'] < self.H4_high and current_bar['Low'] > self.H4_low              )or  \
                (  current_bar['Low'] < self.Min15_low                                                   and  \
                    current_bar['High'] < self.H4_high and current_bar['Low'] > self.H4_low         ):

                if self.check_sweep_origin(self.min15_data_fractal, current_index):                 #Check if liquidity sweep began within KZ
                    if current_bar['High'] < self.H4_equ and self.directional_bias != 0 and self.check_dead_zone(current_bar['High']):       # FT/NFT
                        self.BUY(current_bar, timestamp_utc)
                    elif self.directional_bias == 2 and self.check_dead_zone(current_bar['High']):       # SFT to the up side
                        self.BUY(current_bar, timestamp_utc)
                    else:
                        # add to potential order list. If continued entry point drops below equ then enter 
                        new_order = pd.DataFrame({
                            'Datetime': [timestamp_utc],
                            'Type': ['BUY'], 
                            'Limit': [current_bar['High']], 
                            'SL': [0],
                            'TP': [0], 
                            'Size': [self.position_exposure], 
                            'IsOpen': [True],
                            'Bar': [current_bar['Bar']] })
                        self.potential_orders = pd.concat([self.potential_orders, new_order], ignore_index=True)
            
            # Delayed entry. If a liquidity sweep was originally invalid but continued until entry is below/above equ
            elif not self.potential_orders.empty:
                rows_to_delete = []
                for index, order in self.potential_orders.iterrows():
                    if order['Type'] == 'BUY' and current_bar['High'] < self.H4_equ and order['Bar'] == current_bar['Bar']: 
                        self.BUY(current_bar, timestamp_utc)
                    
                    elif order['Type'] == 'BUY' and current_bar['High'] >= self.H4_equ and order['Bar'] == current_bar['Bar']: 
                        # drop the last potential order bar
                        self.potential_orders.drop(index, inplace=True)
                        # add to potential order list. If continued entry point drops below equ then enter 
                        new_order = pd.DataFrame({
                            'Datetime': [timestamp_utc],
                            'Type': ['BUY'], 
                            'Limit': [current_bar['High']], 
                            'SL': [0],
                            'TP': [0], 
                            'Size': [self.position_exposure], 
                            'IsOpen': [True],
                            'Bar': [current_bar['Bar']] })
                        self.potential_orders = pd.concat([self.potential_orders, new_order], ignore_index=True)
                    
                    elif order['Type'] == 'SELL' and current_bar['Low'] > self.H4_equ and order['Bar'] == current_bar['Bar']: 
                        self.SELL(current_bar, timestamp_utc)
                    
                    elif order['Type'] == 'SELL' and current_bar['High'] <= self.H4_equ and order['Bar'] == current_bar['Bar']: 
                        # Drop the last potential order bar
                        self.potential_orders.drop(index, inplace=True)
                        # add to potential order list. If continued entry point drops below equ then enter 
                        new_order = pd.DataFrame({
                            'Datetime': [timestamp_utc],
                            'Type': ['SELL'], 
                            'Limit': [current_bar['Low']], 
                            'SL': [0],
                            'TP': [0], 
                            'Size': [self.position_exposure], 
                            'IsOpen': [True],
                            'Bar': [current_bar['Bar']] })
                        self.potential_orders = pd.concat([self.potential_orders, new_order], ignore_index=True)
                    
                    elif order['Bar'] != current_bar['Bar']:
                        rows_to_delete.append(index)
                    else: print('something is wrong with delayed orders')
                self.potential_orders.drop(rows_to_delete, inplace=True)

        # set H4 range
        if current_index in self.h4_data_fractal.index:
            H4_data_bar = self.h4_data_fractal.loc[current_index]
            
            # Update 4H range
            if self.H4_last_fractal_high == 0 or self.H4_last_fractal_low == 0:
                # Initial update 4H last fractals
                if H4_data_bar['Fractal'] == "fractal_high":
                    self.H4_last_fractal_high = current_bar['High']
                    self.H4_last_fractal_low = current_bar['Low']
                    self.H4_fractal_high_validity = 1
                if H4_data_bar['Fractal'] == "fractal_low":
                    self.H4_last_fractal_low = current_bar['Low']
                    self.H4_last_fractal_high = current_bar['Low'] 
                    self.H4_fractal_low_validity = 1 
            self.update_H4_range(H4_data_bar)
            self.determine_directional_bias()       

            # Update 4H last fractals
            if H4_data_bar['Fractal'] == "fractal_high":
                self.H4_last_fractal_high = current_bar['High']
                self.H4_fractal_high_validity = 1
            if H4_data_bar['Fractal'] == "fractal_low":
                self.H4_last_fractal_low = current_bar['Low'] 
                self.H4_fractal_low_validity = 1 

        # set last 15 min fractal levels
        if current_bar['Fractal'] == "fractal_high":
            self.fractal_high = current_bar['High']
            self.fractal_high_validity = 1
        if current_bar['Fractal'] == "fractal_low":
            self.fractal_low = current_bar['Low'] 
            self.fractal_low_validity = 1

        # set 15 min range
        if current_bar['High'] > self.Min15_high:
            self.Min15_high = current_bar['High']
            self.Min15_low = self.fractal_low 

        if current_bar['Low'] <  self.Min15_low:
            self.Min15_low = current_bar['Low']
            self.Min15_high = self.fractal_high

        # update fractal validity
        if current_bar['High'] > self.fractal_high:
            self.fractal_high_validity = 0
        if current_bar['Low'] < self.fractal_low:
            self.fractal_low_validity = 0 
        
        # print(self.Limit_orders_not_met)

# Run backtest and print stats/plot
bt = Backtest(min15_data, HTF, cash = 1_000)
stats=bt.run()
bt.plot()
print(stats)
print(stats['_trades'].to_string())