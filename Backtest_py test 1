# Trying Backtesting.py

import pandas as pd
import numpy as np
import yfinance as yf
from backtesting import Backtest, Strategy
from backtesting.test import GOOG
from backtesting.lib import crossover, plot_heatmaps, resample_apply, barssince
import talib
import seaborn as sns
import matplotlib.pyplot as plt

d1_data = yf.download(tickers = 'GBPUSD=X' ,start="2022-06-01", end="2023-5-30", interval = '1d')
"""
h1_data = yf.download(tickers = 'GBPJPY=X' ,start="2022-06-01", end="2023-5-30", interval = '1h')
# 1h to 4h
df_agg = h1_data.groupby(pd.Grouper(freq='4H')).agg({"Open": "first", "High": "max", "Low": "min", "Close": "last","Adj Close": "last"})
h4_data = df_agg.dropna(how='all')
h4_data.columns = ["open", "high", "low", "close", "Adj Close"] 
"""

# def optim_func(series):
#     return series["Equity Final [$]"] / series["Exposure Time [%]"]


class RsiOscillator(Strategy): 

    upper_bound = 70
    lower_bound = 30
    rsi_window = 14
    
    def init(self):
        self.daily_rsi = self.I(talib.RSI, self.data.Close, self.rsi_window)
        # self.weekly_rsi = resample_apply("W-FRI", talib.RSI, self.data.Close, self.rsi_window)

    def next(self):
        price = self.data.Close[-1]

        if ((self.daily_rsi[-1] > self.upper_bound) and barssince(self.daily_rsi<self.upper_bound) == 3):
            self.position.close()

        elif (crossover(self.lower_bound, self.daily_rsi)):
                self.buy(tp = 1.15*price, sl=0.95*price, size=0.1) #10% of available cash

    """  
    if (crossover(self.daily_rsi, self.upper_bound)):
        if self.position.is_long:
            self.position.close()
            self.sell()

    elif (crossover(self.lower_bound, self.daily_rsi)):
        if self.position.is_short or not self.position:
            self.position.close()
            self.buy() 
    """
        
        

bt = Backtest(GOOG, RsiOscillator, cash = 10_000)
"""
stats, heatmap = bt.optimize(
    upper_bound = range(50, 85, 5),
    lower_bound = range(10, 45, 5),
    rsi_window = range(10, 30, 2),
    maximize = "Return [%]",
    # constaint = lambda param: param.upper_bound > param.lower_bound,
    return_heatmap= True)"""
stats=bt.run()

bt.plot()
# print(stats)
print(stats['_trades']).to_string()

# hm = heatmap.groupby(["upper_bound", "lower_bound"]).mean().unstack()
# sns.heatmap(hm)
# plt.show()

# plot_heatmaps(heatmap, agg="mean")