# Using backtesting.py to test SMC strat

import pandas as pd
import numpy as np
import yfinance as yf
from backtesting import Backtest, Strategy
from backtesting.test import GOOG
from backtesting.lib import crossover, plot_heatmaps, resample_apply, barssince
import talib
import seaborn as sns
import matplotlib.pyplot as plt

min15_data = yf.download(tickers = 'GBPUSD=X' ,start="2023-06-01", end="2023-6-27", interval = '15m')
h1_data = yf.download(tickers = 'GBPUSD=X' ,start="2023-06-01", end="2023-6-27", interval = '1h')
# Resample to 4-hour data with custom time offset
h4_data = h1_data.resample('4H', offset='2H').agg({
    'Open': 'first',
    'High': 'max',
    'Low': 'min',
    'Close': 'last',
    'Volume': 'sum'
})

def SMA(values, n):
    return pd.Series(values).rolling(n).mean()

def identify_fractals(data):
            fractal_period = 5
            fractal_dates = []

            def is_bill_williams_fractal(high, low, index):
                if index < 4 or index >= len(high) - 4:
                    return False
                fractal_high = high[index]
                fractal_low = low[index]
                is_high = fractal_high >= max(high[index-2:index+3]) and fractal_high >= max(high[index-1:index+4])
                is_low = fractal_low <= min(low[index-2:index+3]) and fractal_low <= min(low[index-1:index+4])
                return is_high or is_low

            def is_regular_fractal(high, low, index):
                if index < fractal_period or index >= len(high):
                    return False
                fractal_high = high[index]
                fractal_low = low[index]
                is_high = fractal_high >= max(high[index-fractal_period:index+1])
                is_low = fractal_low <= min(low[index-fractal_period:index+1])
                return is_high or is_low

            for i in range(len(data)):
                if is_bill_williams_fractal(data['High'], data['Low'], i):
                    fractal_dates.append((data.index[i], 'fractal_high'))
                elif is_regular_fractal(data['High'], data['Low'], i):
                    fractal_dates.append((data.index[i], 'fractal_low'))

            data['Fractal'] = ''
            for date, fractal_type in fractal_dates:
                data.loc[date, 'Fractal'] = fractal_type

            # Filter consecutive "fractal_low" and keep only the lowest low
            mask = data['Fractal'] == 'fractal_low'
            consecutive_groups = (mask != mask.shift()).cumsum()
            for group_id, group_data in data[mask].groupby(consecutive_groups):
                lowest_low_index = group_data['Low'].idxmin()
                data.loc[group_data.index, 'Fractal'] = ''
                data.loc[lowest_low_index, 'Fractal'] = 'fractal_low'

            # Filter consecutive "fractal_high" and keep only the highest high
            mask = data['Fractal'] == 'fractal_high'
            consecutive_groups = (mask != mask.shift()).cumsum()
            for group_id, group_data in data[mask].groupby(consecutive_groups):
                highest_high_index = group_data['High'].idxmax()
                data.loc[group_data.index, 'Fractal'] = ''
                data.loc[highest_high_index, 'Fractal'] = 'fractal_high'

            return data

class SMC(Strategy): 

    position_exposure = 0.01 #1% of available cash position
    Stop_Pips = 2
    
    n1 = 10
    n2 = 50

    def init(self):
        self.sma1 = self.I(SMA, self.data.Close, self.n1)
        self.sma2 = self.I(SMA, self.data.Close, self.n2)

        h4_data_fractal = identify_fractals(h4_data)
        min15_data_fractal = identify_fractals(min15_data)

        print("4h data", h4_data_fractal.to_string())
        # print("15min data", min15_data_fractal.to_string())

    def next(self):
        pass
        """price = self.data.Close[-1]
        Long_StopLoss = price - self.Stop_Pips*0.01
        Long_Size = (self.position_exposure * self.equity) / self.Stop_Pips
        Short_StopLoss = price + self.Stop_Pips*0.01
        Short_Size = (self.position_exposure * self.equity) / self.Stop_Pips

        
        if crossover(self.sma1, self.sma2):
            self.position.close()


        elif crossover(self.sma2, self.sma1):
            self.buy(tp = (3*self.Stop_Pips)+price , sl=Long_StopLoss, size=0.01)
        """ 

            
# Run backtest and print stats/plot
bt = Backtest(h1_data, SMC, cash = 5_000)
stats=bt.run()
bt.plot()
# print(stats)
# print(stats['_trades']).to_string()
